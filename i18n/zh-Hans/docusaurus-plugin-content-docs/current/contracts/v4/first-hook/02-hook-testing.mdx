---
id: testing-hooks
title: 测试 Hooks
sidebar_position: 2
---

## 测试 Hooks
测试 Hooks 和测试合约一样。模板中包含了对 Counter Hook 的测试，你可以在 `test/Counter.t.sol` 中找到。

以下是关于 Counter Hook 测试的一些关键点：
1. 这个 Hook 扩展了几个实用工具，这些工具使 Hook 的测试变得更加容易。

  ```solidity
  import "forge-std/Test.sol";
  import {Deployers} from "v4-core/test/utils/Deployers.sol";

  contract CounterTest is Test, Deployers {
  }
  ```

2. `setup` 函数，在每个测试之前调用，创建了一些测试代币，获取了 Hook 地址，然后使用这个 Hook 地址初始化池子。

  ```solidity
  function setup() public {
      Deployers.deployFreshManagerAndRouters();
      (currency0, currency1) = Deployers.deployMintAndApprove2Currencies();

      // 将 Hook 部署到带有正确标志的地址
      uint160 flags = uint160(
          Hooks.BEFORE_SWAP_FLAG | Hooks.AFTER_SWAP_FLAG | Hooks.BEFORE_ADD_LIQUIDITY_FLAG
          | Hooks.BEFORE_REMOVE_LIQUIDITY_FLAG
      );
      (address hookAddress, bytes32 salt) =
          HookMiner.find(address(this), flags, type(Counter).creationCode, abi.encode(address(manager)));
      counter = new Counter{salt: salt}(IPoolManager(address(manager)));
  }
  ```

  然后使用这个 Hook 初始化池子
  ```solidity
    // 创建池子
    key = PoolKey(currency0, currency1, 3000, 60, IHooks(counter));
    poolId = key.toId();
    initializeRouter.initialize(key, SQRT_RATIO_1_1, ZERO_BYTES);
  ```

3. Hook 测试利用了一个路由器，即 `PoolModifyPositionTest`，来修改仓位。`PoolModifyPositionTest` 实现了 `ILockCallback` 接口，并添加了 `lockAcquired` 函数，该函数反过来调用 `manager.modifyPosition` 函数。
  ```solidity
    PoolManager manager;
    PoolModifyPositionTest modifyPositionRouter;

    manager = new PoolManager(500000);

    // 与池子交互的辅助工具
    modifyPositionRouter = new PoolModifyPositionTest(IPoolManager(address(manager)));

    modifyPositionRouter.modifyPosition(poolKey, IPoolManager.ModifyPositionParams(-120, 120, 10 ether), ZERO_BYTES);
  ```
  同样地，对于代币交换，测试使用了 `PoolSwapTest`，它也实现了 `ILockCallback` 接口。

4. 测试 Hook 类似于测试任何其他智能合约。函数 `testCounterHooks` 执行交换并验证计数器是否正确更新。

  ```solidity
  function testCounterHooks() public {
      // 仓位在 setup() 中创建
      assertEq(counter.beforeAddLiquidityCount(poolId), 3);
      assertEq(counter.beforeRemoveLiquidityCount(poolId), 0);

      assertEq(counter.beforeSwapCount(poolId), 0);
      assertEq(counter.afterSwapCount(poolId), 0);

      // 执行一个测试交换 //
      bool zeroForOne = true;
      int256 amountSpecified = 1e18;
      BalanceDelta swapDelta = swap(key, zeroForOne, amountSpecified, ZERO_BYTES);
      // ------------------- //

      assertEq(int256(swapDelta.amount0()), amountSpecified);

      assertEq(counter.beforeSwapCount(poolId), 1);
      assertEq(counter.afterSwapCount(poolId), 1);
  }

  /// 测试辅助函数
  function swap(
      PoolKey memory key,
      bool zeroForOne,
      int256 amountSpecified,
      bytes memory hookData
  ) internal returns (BalanceDelta delta) {
      IPoolManager.SwapParams memory params = IPoolManager.SwapParams({
          zeroForOne: zeroForOne,
          amountSpecified: amountSpecified,
          sqrtPriceLimitX96: zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1 // 无限影响
      });

      PoolSwapTest.TestSettings memory testSettings =
          PoolSwapTest.TestSettings({withdrawTokens: true, settleUsingTransfer: true, currencyAlreadySent: false});

      delta = swapRouter.swap(key, params, testSettings, hookData);
  }
  ```