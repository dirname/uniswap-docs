"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[2489],{27747:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=i(83117),a=(i(67294),i(3905));const o={id:"managing-positions",title:"Managing Positions",sidebar_position:2},r="Position",s={unversionedId:"contracts/v4/concepts/managing-positions",id:"contracts/v4/concepts/managing-positions",title:"Managing Positions",description:"To add or remove the tokens we call the function modifyPosition which is defined in PoolManager.sol file",source:"@site/docs/contracts/v4/concepts/03-managing-position.mdx",sourceDirName:"contracts/v4/concepts",slug:"/contracts/v4/concepts/managing-positions",permalink:"/uniswap-docs/en/contracts/v4/concepts/managing-positions",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/v4/concepts/03-managing-position.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"managing-positions",title:"Managing Positions",sidebar_position:2},sidebar:"contractsSidebar",previous:{title:"Pool Manager and Pool Initialization",permalink:"/uniswap-docs/en/contracts/v4/concepts/pool-manager-and-pool-initialization"},next:{title:"Swap Tokens",permalink:"/uniswap-docs/en/contracts/v4/concepts/swap-tokens"}},c={},l=[{value:"Tick",id:"tick",level:3},{value:"Tick Spacing",id:"tick-spacing",level:3},{value:"SquareRoot Price X96",id:"squareroot-price-x96",level:3},{value:"1. <strong>Square Root Price:</strong>",id:"1-square-root-price",level:3},{value:"2. <strong>X96:</strong>",id:"2-x96",level:3},{value:"SqrtPriceX96 to Tick",id:"sqrtpricex96-to-tick",level:3},{value:"Liquidity Delta",id:"liquidity-delta",level:3}],p={toc:l};function d(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"position"},"Position"),(0,a.kt)("p",null,"To add or remove the tokens we call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"modifyPosition")," which is defined in ",(0,a.kt)("inlineCode",{parentName:"p"},"PoolManager.sol")," file"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"struct ModifyPositionParams {\n   // the lower and upper tick of the position\n   int24 tickLower;\n   int24 tickUpper;\n   // how to modify the liquidity\n   int256 liquidityDelta;\n}\n\n/// @notice Modify the position for the given pool\nfunction modifyPosition(PoolKey memory key, ModifyPositionParams memory params, bytes calldata hookData)\nexternal\nreturns (BalanceDelta);\n")),(0,a.kt)("h1",{id:"important-concepts"},"Important Concepts"),(0,a.kt)("p",null,"Some of the important concepts to understand when working with Uniswap V3 or V4 positions are:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Tick"),(0,a.kt)("li",{parentName:"ol"},"Tick Spacing"),(0,a.kt)("li",{parentName:"ol"},"SquareRoot Price X96"),(0,a.kt)("li",{parentName:"ol"},"Liquidity Delta")),(0,a.kt)("h3",{id:"tick"},"Tick"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"tick")," is a measure used in this code to handle prices of two different assets (tokens) in a unique way. A ",(0,a.kt)("inlineCode",{parentName:"p"},"tick"),"\nrepresents a specific price ratio between these two assets, calculated using a mathematical formula."),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"Price And Ticks",src:i(45699).Z,width:"3051",height:"1657"})),(0,a.kt)("p",null,"There are minimum and maximum ",(0,a.kt)("inlineCode",{parentName:"p"},"tick")," values defined within the code, ensuring that calculated prices are within a\nreasonable and acceptable range."),(0,a.kt)("p",null,"In Uniswap V3 (and V4), liquidity providers can provide liquidity at specific price ranges (ticks), allowing them to\nconcentrate their liquidity and potentially earn more fees."),(0,a.kt)("p",null,"Each tick corresponds to a specific price, and not all prices are represented due to the discrete nature of the ticks."),(0,a.kt)("h3",{id:"tick-spacing"},"Tick Spacing"),(0,a.kt)("p",null,"The tick spacing is a parameter that determines the separation between these usable ticks, making only every\nNth tick available for liquidity provision, where ",(0,a.kt)("inlineCode",{parentName:"p"},"N")," is the tick spacing. This is a form of quantization of\nthe price levels that liquidity can be provided at."),(0,a.kt)("h3",{id:"squareroot-price-x96"},"SquareRoot Price X96"),(0,a.kt)("p",null,"In Uniswap V3 (and V4), the square root price (",(0,a.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96"),") is a key concept and a crucial part of the mathematical\ncalculations. It's utilized for various calculations, including determining the amount of tokens that should be moved\nduring a swap and the liquidity calculations within specific price ranges."),(0,a.kt)("p",null,"Here\u2019s a breakdown of what ",(0,a.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96")," represents:"),(0,a.kt)("h3",{id:"1-square-root-price"},"1. ",(0,a.kt)("strong",{parentName:"h3"},"Square Root Price:")),(0,a.kt)("p",null,"The price is represented as the square root of the actual price ratio of the tokens. This representation\nsimplifies the math, especially when it comes to calculating the amounts to be swapped, as well as the\nliquidity calculations within tick ranges."),(0,a.kt)("h3",{id:"2-x96"},"2. ",(0,a.kt)("strong",{parentName:"h3"},"X96:")),(0,a.kt)("p",null,"The X96 suffix refers to the fixed-point format used. Uniswap V3 utilizes a 96-bit fixed-point number format.\nIn this representation, there is a convention to maintain high precision in calculations. The fixed-point\nrepresentation means that the actual floating-point number is multiplied by ","(","2^{96}",")"," and stored as an\ninteger. When reading the value, it has to be interpreted properly by dividing it by ","(","2^{96}",")"," to get the\nactual value."),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"SqrtPriceX96",src:i(80891).Z,width:"3051",height:"1276"})),(0,a.kt)("h3",{id:"sqrtpricex96-to-tick"},"SqrtPriceX96 to Tick"),(0,a.kt)("p",null,"Since both the ",(0,a.kt)("inlineCode",{parentName:"p"},"tick")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96")," are representations of the price, they can be converted from one to the other."),(0,a.kt)("p",null,"The Uniswap V3/V4 core library provides two functions to convert between the two representations:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/v4-core/blob/main/src/libraries/TickMath.sol"},"https://github.com/Uniswap/v4-core/blob/main/src/libraries/TickMath.sol")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The function ",(0,a.kt)("inlineCode",{parentName:"p"},"getSqrtRatioAtTick")," takes a ",(0,a.kt)("inlineCode",{parentName:"p"},"tick")," value as an input, and it computes the square root of the price\nratio of the two assets at that specific ",(0,a.kt)("inlineCode",{parentName:"p"},"tick"),". The result represents the price relationship between two\nassets in a particular state or position.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"getTickAtSqrtRatio")," function does the reverse\u2014it takes a square root of a price ratio and calculates\nthe corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},"tick"),". This ",(0,a.kt)("inlineCode",{parentName:"p"},"tick")," value represents a position or state where the assets have the given\nprice relationship."))),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"sqrtPriceX96 to Tick",src:i(26841).Z,width:"3051",height:"1276"})),(0,a.kt)("h3",{id:"liquidity-delta"},"Liquidity Delta"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"liquidityDelta")," is the difference between the current liquidity and the desired liquidity in a position. It can\nbe positive (when you're adding liquidity) or negative (when you're removing liquidity)."),(0,a.kt)("p",null,"Here is the code from Uniswap V3 contracts which calculates the liquidity (or liquidityDelta):"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/LiquidityManagement.sol"},"https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/LiquidityManagement.sol")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"   (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n   uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);\n   uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);\n\n   liquidity = LiquidityAmounts.getLiquidityForAmounts(\n       sqrtPriceX96,\n       sqrtRatioAX96,\n       sqrtRatioBX96,\n       params.amount0Desired,\n       params.amount1Desired\n   );\n")),(0,a.kt)("h1",{id:"example---add-liquidity"},"Example - Add Liquidity"),(0,a.kt)("p",null,"Here is the code that adds liquidity to a position"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"int24 tickLower = -600;\nint24 tickUpper = 600;\nuint256 liquidity = 1e18;\n\nPoolManager manager = new PoolManager(500000);\n// Helpers for interacting with the pool\nPoolModifyPositionTest modifyPositionRouter = new PoolModifyPositionTest(IPoolManager(address(manager)));\n\nmodifyPositionRouter.modifyPosition(\n    poolKey,\n    IPoolManager.ModifyPositionParams({\n        tickLower: tickLower,\n        tickUpper: tickUpper,\n        liquidityDelta: int256(liquidity)\n    }),\n    ZERO_BYTES\n);\n")),(0,a.kt)("p",null,"Note: ",(0,a.kt)("inlineCode",{parentName:"p"},"PoolModifyPositionTest")," implements the ",(0,a.kt)("inlineCode",{parentName:"p"},"ILockCallback")," interface and adds the ",(0,a.kt)("inlineCode",{parentName:"p"},"lockAcquired")," function, which in turn calls the ",(0,a.kt)("inlineCode",{parentName:"p"},"manager.modifyPosition")," function."),(0,a.kt)("h1",{id:"acquiring-lock"},"Acquiring Lock"),(0,a.kt)("p",null,"Full detail about the locking mechanism is explained in the ",(0,a.kt)("a",{parentName:"p",href:"/03_Locking_Mechanism/README.md"},"Locking Mechanism")," section."),(0,a.kt)("p",null,"The contract that calls the ",(0,a.kt)("inlineCode",{parentName:"p"},"modifyPosition")," must implement ILockCallback interface."),(0,a.kt)("p",null,"PoolModifyPositionTest.sol has some examples of how to acquire lock and some basic checks in place.\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/v4-core/blob/main/src/test/PoolModifyPositionTest.sol"},"https://github.com/Uniswap/v4-core/blob/main/src/test/PoolModifyPositionTest.sol")),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"PoolModifyPositionTest")," the ",(0,a.kt)("inlineCode",{parentName:"p"},"lockAcquired")," function is executed when the lock is acquired, handling\nbalance adjustments and interactions with external currencies and contracts. The function takes raw\nencoded data as input, which is then decoded into structured data, specifically ",(0,a.kt)("inlineCode",{parentName:"p"},"CallbackData"),". Essential\nvalidations and checks are performed, ensuring the caller of the function is the manager, and it\nprocesses the modifications such as settling amounts and making necessary transfers based on\nconditions like whether the amount being positive or negative."))}d.isMDXComponent=!0},3905:(e,t,i)=>{i.d(t,{Zo:()=>p,kt:()=>h});var n=i(67294);function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function r(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){a(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),i=t;return e&&(i="function"==typeof e?e(t):r(r({},t),e)),i},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var i=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(i),h=a,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||o;return i?n.createElement(m,r(r({ref:t},p),{},{components:i})):n.createElement(m,r({ref:t},p))}));function h(e,t){var i=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=i.length,r=new Array(o);r[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var l=2;l<o;l++)r[l]=i[l];return n.createElement.apply(null,r)}return n.createElement.apply(null,i)}u.displayName="MDXCreateElement"},45699:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/PriceAndTicks-7d6a1883a754da8cd6ff437d57a0c421.png"},80891:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/SqrtPriceX96-4ab21b077872dd7091948df8aac3264e.png"},26841:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/sqrtPriceX96_to_tick-3b3b8c71986acf9e520e4988e6f1c89f.png"}}]);