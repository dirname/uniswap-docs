"use strict";(self.webpackChunk_uniswap_docs=self.webpackChunk_uniswap_docs||[]).push([[3854],{35997:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var a=t(83117),o=(t(67294),t(3905));const r={id:"lock-mechanism",title:"Lock Mechanism - Flash Accounting",sidebar_position:4},l="Intro to Locking",i={unversionedId:"contracts/v4/concepts/lock-mechanism",id:"contracts/v4/concepts/lock-mechanism",title:"Lock Mechanism - Flash Accounting",description:"The locking mechanism in V4 ensures that certain operations are executed atomically without interference, ensuring",source:"@site/docs/contracts/v4/concepts/05-lock-mechanism.mdx",sourceDirName:"contracts/v4/concepts",slug:"/contracts/v4/concepts/lock-mechanism",permalink:"/uniswap-docs/en/contracts/v4/concepts/lock-mechanism",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/docs/contracts/v4/concepts/05-lock-mechanism.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"lock-mechanism",title:"Lock Mechanism - Flash Accounting",sidebar_position:4},sidebar:"contractsSidebar",previous:{title:"Swap Tokens",permalink:"/uniswap-docs/en/contracts/v4/concepts/swap-tokens"},next:{title:"Hook Deployment",permalink:"/uniswap-docs/en/contracts/v4/concepts/hook-deployment"}},c={},s=[{value:"1. <strong>Locking and Unlocking:</strong>",id:"1-locking-and-unlocking",level:3},{value:"2. <strong>Lockers.sol</strong>",id:"2-lockerssol",level:3},{value:"3. <strong>Non-Zero Deltas Tracking(Flash Accounting):</strong>",id:"3-non-zero-deltas-trackingflash-accounting",level:3},{value:"Working",id:"working",level:3}],k={toc:s};function d(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"intro-to-locking"},"Intro to Locking"),(0,o.kt)("p",null,"The locking mechanism in V4 ensures that certain operations are executed atomically without interference, ensuring\nconsistency and correctness in the PoolManager's state. PoolManager, uses ",(0,o.kt)("inlineCode",{parentName:"p"},"Lockers")," to manage a queue of\nlockers, ensuring that all currency deltas are settled before releasing a lock."),(0,o.kt)("p",null,"Pool actions can be taken by acquiring a lock on the contract and implementing the ",(0,o.kt)("inlineCode",{parentName:"p"},"lockAcquired")," callback to\nthen proceed with any of the following actions on the pools:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"swap")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"modifyPosition")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"donate")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"take")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"settle")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"mint"))),(0,o.kt)("h1",{id:"main-components"},"Main Components"),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"PoolManager"),', "locking" is essentially a way to ensure certain operations are coordinated and don\'t interfere\nwith each other. Here are the main components of the locking mechanism:'),(0,o.kt)("h3",{id:"1-locking-and-unlocking"},"1. ",(0,o.kt)("strong",{parentName:"h3"},"Locking and Unlocking:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"lock")," function is where the locking mechanism is initiated. It pushes an address tuple (address locker, address lockCaller)\nto the locker array."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function lock(address lockTarget, bytes calldata data) external payable override returns (bytes memory result) {\n    Lockers.push(lockTarget, msg.sender);\n\n    // the caller does everything in this callback, including paying what they owe via calls to settle\n    result = ILockCallback(lockTarget).lockAcquired(msg.sender, data);\n\n    if (Lockers.length() == 1) {\n        if (Lockers.nonzeroDeltaCount() != 0) revert CurrencyNotSettled();\n        Lockers.clear();\n    } else {\n        Lockers.pop();\n    }\n}\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"During the lock, a callback function ",(0,o.kt)("inlineCode",{parentName:"p"},"ILockCallback(lockTarget).lockAcquired(msg.sender, data)")," is called, where the locked\ncontract can perform necessary operations.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"After the operations in the callback are completed, it either clears the ",(0,o.kt)("inlineCode",{parentName:"p"},"Lockers")," if it has only element,\nsignifying the release of the lock, or it pops the last element from ",(0,o.kt)("inlineCode",{parentName:"p"},"Lockers"),", signifying that the lock is\nreleased by that particular address."))),(0,o.kt)("h3",{id:"2-lockerssol"},"2. ",(0,o.kt)("strong",{parentName:"h3"},"Lockers.sol")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Lockers")," library stores an array/queue of locker addresses and their corresponding lock callers in transient storage.\nEach locker is represented as a tuple (address locker, address lockCaller), and each tuple occupies two slots in\ntransient storage. The functions ",(0,o.kt)("inlineCode",{parentName:"p"},"push"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"pop"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"length"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"clear")," are used to manage this queue."),(0,o.kt)("h3",{id:"3-non-zero-deltas-trackingflash-accounting"},"3. ",(0,o.kt)("strong",{parentName:"h3"},"Non-Zero Deltas Tracking(Flash Accounting):")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"Lockers")," library also includes a mechanism to keep track of the number of nonzero deltas\nthrough ",(0,o.kt)("inlineCode",{parentName:"li"},"nonzeroDeltaCount"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"incrementNonzeroDeltaCount"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"decrementNonzeroDeltaCount"),". These functions tracks\nthe number of changes or deltas that have occurred and these deltas are checked before releasing the lock.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"_accountDelta")," function tracks the balance changes (delta) for each locker with respect to a specific currency.\nIt first checks if the delta (change in balance) is zero; if it is, the function\nreturns immediately as there's no change to account for. If there's a non-zero delta, the function retrieves the\ncurrent balance for the specified locker and currency, and then calculates the new balance by adding the delta\nto the current balance."),(0,o.kt)("p",{parentName:"li"},"  The function also uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"Lockers")," library to increment or decrement the ",(0,o.kt)("inlineCode",{parentName:"p"},"nonzeroDeltaCount"),"  that tracks the number\nof non-zero balance changes."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function _accountDelta(Currency currency, int128 delta) internal {\nif (delta == 0) return;\n\n      address locker = Lockers.getCurrentLocker();\n      int256 current = currencyDelta[locker][currency];\n      int256 next = current + delta;\n\n      unchecked {\n          if (next == 0) {\n              Lockers.decrementNonzeroDeltaCount();\n          } else if (current == 0) {\n              Lockers.incrementNonzeroDeltaCount();\n          }\n      }\n\n      currencyDelta[locker][currency] = next;\n}\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},'This mechanism is a key component of what is termed "Flash Accounting" in Uniswap V4. Flash Accounting is an\ninnovative approach introduced with the new singleton-style pool management. This feature fundamentally\nalters the management of tokens during transaction processes. Traditional methods typically require explicit\ntracking of token balances at every operational phase. In contrast, Flash Accounting operates under the principle\nthat by the end of each transaction or "lock period," there should be no net tokens owed either to the pool or the\ncaller, streamlining the accounting process significantly.'))),(0,o.kt)("h3",{id:"working"},"Working"),(0,o.kt)("p",null,"The locking mechanism in the PoolManager contract works as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"When a user wants to lock, they call the ",(0,o.kt)("inlineCode",{parentName:"li"},"lock()")," function with the data that they want to be passed to the callback."),(0,o.kt)("li",{parentName:"ol"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"lock()")," function pushes the tuple (address locker, address lockCaller) onto the locker queue."),(0,o.kt)("li",{parentName:"ol"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"lock()")," function then calls the ",(0,o.kt)("inlineCode",{parentName:"li"},"ILockCallback(lockTarget).lockAcquired(msg.sender, data)")," callback."),(0,o.kt)("li",{parentName:"ol"},"The callback can do whatever it needs to do, such as updating the user's balances or interacting with other contracts."),(0,o.kt)("li",{parentName:"ol"},"Once the callback is finished, it returns to the ",(0,o.kt)("inlineCode",{parentName:"li"},"lock()")," function."),(0,o.kt)("li",{parentName:"ol"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"lock()")," function checks if there are any other lockers in the queue. If there are, it pops the next locker off the queue and calls the callback for that locker."),(0,o.kt)("li",{parentName:"ol"},"If there are no more lockers in the queue, the ",(0,o.kt)("inlineCode",{parentName:"li"},"lock()")," function returns.")),(0,o.kt)("h1",{id:"example"},"Example"),(0,o.kt)("p",null,"Below is the example from a community ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/kadenzipfel/uni-lbp/blob/main/src/LiquidityBootstrappingHooks.sol"},'"Liquidity Bootstrapping Hook"')," hook that uses the locking mechanism and calls the ",(0,o.kt)("inlineCode",{parentName:"p"},"modifyPosition")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"swap")," functions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'/// @notice Callback function called by the poolManager when a lock is acquired\n///         Used for modifying positions and swapping tokens internally\n/// @param data Data passed to the lock function\n/// @return Balance delta\nfunction lockAcquired(bytes calldata data) external override poolManagerOnly returns (bytes memory) {\n    bytes4 selector = abi.decode(data[:32], (bytes4));\n\n    if (selector == IPoolManager.modifyPosition.selector) {\n        ModifyPositionCallback memory callback = abi.decode(data[32:], (ModifyPositionCallback));\n\n        BalanceDelta delta = poolManager.modifyPosition(callback.key, callback.params, bytes(""));\n\n        if (callback.params.liquidityDelta < 0) {\n            // Removing liquidity, take tokens from the poolManager\n            _takeDeltas(callback.key, delta, callback.takeToOwner); // Take to owner if specified (exit)\n        } else {\n            // Adding liquidity, settle tokens to the poolManager\n            _settleDeltas(callback.key, delta);\n        }\n\n        return abi.encode(delta);\n    }\n\n    if (selector == IPoolManager.swap.selector) {\n        SwapCallback memory callback = abi.decode(data[32:], (SwapCallback));\n\n        BalanceDelta delta = poolManager.swap(callback.key, callback.params, bytes(""));\n\n        // Take and settle deltas\n        _takeDeltas(callback.key, delta, true); // Take tokens to the owner\n        _settleDeltas(callback.key, delta);\n\n        return abi.encode(delta);\n    }\n\n    return bytes("");\n}\n')),(0,o.kt)("p",null,"Other important thing to note is that before the lock is released, the ",(0,o.kt)("inlineCode",{parentName:"p"},"nonzeroDeltaCount")," is checked to ensure that\nall currency deltas are settled. This is done by ",(0,o.kt)("inlineCode",{parentName:"p"},"_takeDeltas")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"_settleDeltas")," functions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @notice Helper function to take tokens according to balance deltas\n/// @param delta Balance delta\n/// @param takeToOwner Whether to take the tokens to the owner\nfunction _takeDeltas(PoolKey memory key, BalanceDelta delta, bool takeToOwner) internal {\n    PoolId poolId = key.toId();\n    int256 delta0 = delta.amount0();\n    int256 delta1 = delta.amount1();\n\n    if (delta0 < 0) {\n        poolManager.take(key.currency0, takeToOwner ? owner[poolId] : address(this), uint256(-delta0));\n    }\n\n    if (delta1 < 0) {\n        poolManager.take(key.currency1, takeToOwner ? owner[poolId] : address(this), uint256(-delta1));\n    }\n}\n\n/// @notice Helper function to settle tokens according to balance deltas\n/// @param key Pool key\n/// @param delta Balance delta\nfunction _settleDeltas(PoolKey memory key, BalanceDelta delta) internal {\n    int256 delta0 = delta.amount0();\n    int256 delta1 = delta.amount1();\n\n    if (delta0 > 0) {\n        key.currency0.transfer(address(poolManager), uint256(delta0));\n        poolManager.settle(key.currency0);\n    }\n\n    if (delta1 > 0) {\n        key.currency1.transfer(address(poolManager), uint256(delta1));\n        poolManager.settle(key.currency1);\n    }\n}\n")))}d.isMDXComponent=!0},3905:(e,n,t)=>{t.d(n,{Zo:()=>k,kt:()=>u});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},k=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,k=i(e,["components","mdxType","originalType","parentName"]),p=s(t),u=o,m=p["".concat(c,".").concat(u)]||p[u]||d[u]||r;return t?a.createElement(m,l(l({ref:n},k),{},{components:t})):a.createElement(m,l({ref:n},k))}));function u(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,l=new Array(r);l[0]=p;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,l[1]=i;for(var s=2;s<r;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);